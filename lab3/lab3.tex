\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{float}
\usepackage{pythonhighlight}

% \geometry{left=2.0cm,right=2.0cm,top=2.5cm,bottom=2.5cm}

\title{
    \textbf{\Huge ECE374 Fall2020} \\
    \textbf{\Large Lab3: Optimized Merge Sort}
    }

\author{\large Name: Zhang Yichi 3180111309}

\date{Oct. $20^{th}$ 2020}

\begin{document}
\setlength{\parindent}{0pt}
\maketitle
\section{Introduction}
In this lab, we will optimize the merge sort by modifying the sorting of small size problems. Instead of dividing the problem size to 1 by recursion then merge them, we stop when the leaves contain less than k elements and apply insertion sort to sort the sublists since insertion sort is more efficient in small size problems.

\section{Python Code}
\inputpython{lab3.py}{3}{39}

\section{Test Example}
Here, 20 random floating numbers are generated by np.random.randn. We use the optimized merge sort with $k=3$ (the best k is around 60 to 80, here we just choose a k to test the algorithm) to sort them and output the result. 
\inputpython{lab3.py}{42}{46}
\begin{figure}[H]
    \centering
    \includegraphics[width=15cm]{example.png}
    \caption{Example inputs and outputs for 20 random floating numbers}
\end{figure}

\section{Indication}
We first build a normal merge sort where we divide the lists in half, merge sort the two sublists and finally merge them back to one list. \\

For merging the two sublists, we take the first one of the elements in both sublists, compare them, add the smaller one to a new list and take the latter one element of the smaller one and repeat the compare, add-to-new-list, take-new-element process until one sublist is empty. After that, we add all the rest elements in the nonempty sublist to the new list. \\

The modification is that instead of dividing the problem size to 1, we stop when the problem size is less than k and call the insertion sort to sort the sublists. \\

For the insertion sort, we take the elements one by one in order, compare them with the ones ahead, find the place they should be and insert them into those places.

\section{Complexity Analysis}
For the original merge sort, the height of the recursion tree is $\frac{n}{2^h}=1 \Rightarrow h=logn$\\

For the optimized merge sort, the height of the recursion tree is $\frac{n}{2^h}=k \Rightarrow h=log\frac{n}{k}$ approximately since k is not necessarily be a power of 2.\\

The width of one layer of the recursion tree is n, the total number of the elements in the list, which stays the same.\\

The time complexity of the insertion sort is $O(k^2)$\\

The time complexity of the merge sort is $O(nlog\frac{n}{k})+O(k^2)$\\

To best optimize the time complexity, we need $O(k^2) \leq O(nlog\frac{n}{k})$ and therefore the final time complexity will be $O(nlog\frac{n}{k})=O(nlogn)$. \\

\end{document}